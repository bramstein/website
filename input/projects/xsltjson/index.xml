<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN"
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
<article>
  <title>XSLTJSON, XML to JSON using XSLT</title>

  <sidebar id="test1">
    <title>Download</title>

    <para>Download: <ulink url="xml-to-json.xsl">xml-to-json.xsl</ulink>
    (XSLTJSON v0.7 - 2008-09-03 - 15 kB)</para>
  </sidebar>

  <sidebar>
    <title>Requirements</title>

    <para>XSLTJSON requires an <acronym>XSLT</acronym> 2.0 processor. An
    excellent option is <ulink url="http://www.saxonica.com/">Saxon</ulink>,
    which was used to test and develop XSLTJSON.</para>
  </sidebar>

  <sidebar>
    <title>XSLT 2.0?</title>

    <para>Don't have an XSLT 2.0 processor? Check out <ulink
    url="http://alanlewis.typepad.com/">Alan Lewis</ulink>'s excellent <ulink
    url="xml-2-json.xsl">XML 2 JSON project</ulink>, or <ulink
    url="http://onperl.org/blog/onperl/page/rayfish">Micheal Matthew's Rayfish
    project</ulink>.</para>
  </sidebar>

  <sidebar>
    <title>License</title>

    <para>XSLTJSON is licensed under the <ulink
    url="/licenses/BSD.txt">revised BSD license</ulink>. To summarize the
    license; XSLTJSON is completely free for commercial and non-commercial use
    and you can do with it whatever you want, except claim it as your own. The
    complete license can be found in the header of the stylesheet.</para>
  </sidebar>

  <section>
    <title>Introduction</title>

    <para>XSLTJSON is an <acronym>XSLT</acronym> 2.0 stylesheet to transform
    arbitrary <acronym>XML</acronym> to <ulink
    url="http://json.org/">JavaScript Object Notation</ulink>
    (<acronym>JSON</acronym>). <acronym>JSON</acronym> is a lightweight
    data-interchange format based on a subset of the <ulink
    url="http://en.wikipedia.org/wiki/JavaScript">JavaScript language</ulink>,
    and often offered as an alternative to <acronym>XML</acronym> in—for
    example—web services. To make life easier XSLTJSON allows you to transform
    <acronym>XML</acronym> to <acronym>JSON</acronym> automatically.</para>

    <para>XSLTJSON supports several different <acronym>JSON</acronym> output
    formats, from a compact output format to support for the <ulink
    url="http://badgerfish.ning.com/">BadgerFish convention</ulink>, which
    allows round-trips between <acronym>XML</acronym> and
    <acronym>JSON</acronym>. To make things even better, it is completely free
    and open-source.</para>
  </section>

  <section>
    <title>Usage</title>

    <para>There are three options in using XSLTJSON. You can call the
    stylesheet from the command line, programmatically, or import it in your
    own stylesheets.</para>

    <para>The stylesheet example below would transform any node matching
    <literal>my-node</literal> to <acronym>JSON</acronym>. If you import
    XSLTJSON in your stylesheet, you have to add the <acronym>JSON</acronym>
    namespace <literal>xmlns:json="http://json.org/"</literal> to your
    stylesheet because all functions and templates are in that namespace. The
    <literal>json:generate()</literal> function takes a <acronym>XML</acronym>
    node as input, generates a <acronym>JSON</acronym> representation of that
    node and returns it as an <literal>xs:string</literal>. This is the only
    function you should call from your stylesheet.</para>

    <programlisting>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet version="2.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:json="http://json.org/"&gt;
    &lt;xsl:import href="xml-to-json.xsl"/&gt;
    &lt;xsl:template match="my-node"&gt;
        &lt;xsl:value-of select="json:generate(.)"/&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</programlisting>

    <para>If your stylesheet's sole purpose is to transform
    <acronym>XML</acronym> to <acronym>JSON</acronym>, it would be easier to
    use the <filename>xml-to-json.xsl</filename> stylesheet directly from the
    command line. The following line shows how to do that using <ulink
    url="http://java.sun.com/">Java</ulink> and <ulink
    url="http://www.saxonica.com/">Saxon</ulink>.</para>

    <programlisting>java net.sf.saxon.Transform source.xml xml-to-json.xsl</programlisting>

    <para>You can also call the stylesheet programmatically, but this depends
    heavily on your programming environment, so please consult the
    documentation of your programming language or <acronym>XSLT</acronym>
    processor.</para>

    <section>
      <title>Parameters</title>

      <para>There are five Boolean parameters to control the stylesheet, and
      all are turned off by default (set to <literal>false()</literal>.) You
      can control them from the command line, from your program or from
      another stylesheet. Four of the parameters are used to control the
      output format and are discussed in more detail in the section on <link
      endterm="output-formats" linkend="output-formats">output
      formats</link>.</para>

      <itemizedlist>
        <listitem>
          <para><literal>use-badgerfish</literal> — Use the <ulink
          url="http://badgerfish.ning.com/">BadgerFish</ulink> convention to
          output <acronym>JSON</acronym> <emphasis>without</emphasis>
          <acronym>XML</acronym> namespaces.</para>
        </listitem>

        <listitem>
          <para><literal>use-rabbitfish</literal> — Output basic
          <acronym>JSON</acronym> with an <literal>@</literal> to mark
          <acronym>XML</acronym> attributes.</para>
        </listitem>

        <listitem>
          <para><literal>use-rayfish</literal> — Use the <ulink
          url="http://onperl.org/blog/onperl/page/rayfish">Rayfish</ulink>
          convention to output <acronym>JSON</acronym>
          <emphasis>without</emphasis> <acronym>XML</acronym>
          namespaces.</para>
        </listitem>

        <listitem>
          <para><literal>use-namespaces</literal> — Output
          <acronym>XML</acronym> namespaces according to the BadgerFish
          convention.</para>
        </listitem>

        <listitem>
          <para><literal>debug</literal> — Enable or disable the output of the
          temporary <acronym>XML</acronym> tree used to generate
          <acronym>JSON</acronym>. Note that turning this on invalidates the
          <acronym>JSON</acronym> output.</para>
        </listitem>

        <listitem>
          <para><literal>jsonp</literal> — Enable <ulink
          url="http://bob.pythonmac.org/archives/2005/12/05/remote-json-jsonp/">JSONP</ulink>;
          prepend the <acronym>JSON</acronym> output with the given string.
          Defaults to an empty string.</para>
        </listitem>
      </itemizedlist>

      <para>For example; to transform <filename>source.xml</filename> to
      BadgerFish <acronym>JSON</acronym> with Saxon, you would invoke the
      following on the command line:</para>

      <programlisting>java net.sf.saxon.Transform source.xml xml-to-json.xsl use-badgerfish=true()</programlisting>

      <para>For other options consult the <ulink
      url="http://www.saxonica.com/documentation/index/intro.html">Saxon
      manual</ulink>, or your <acronym>XSLT</acronym> processor's
      documentation.</para>

      <para>If you import the stylesheet in your own stylesheet you can
      override the default parameters by redefining them. So if you want to
      output <acronym>JSON</acronym> using the BadgerFish convention, you
      should add the following parameter definition to your stylesheet.</para>

      <programlisting>    &lt;xsl:param name="use-badgerfish" as="xs:boolean" select="true()"/&gt;</programlisting>
    </section>

    <section>
      <title id="output-formats">Output formats</title>

      <para>There are four output formats in XSLTJSON, which one to use
      depends on your target application. If you want the most compact
      <acronym>JSON</acronym>, use the basic output. If you want to transform
      <acronym>XML</acronym> to <acronym>JSON</acronym> and
      <acronym>JSON</acronym> back to <acronym>XML</acronym>, use the <ulink
      url="http://badgerfish.ning.com/">BadgerFish</ulink> output. If you want
      something in between, you could use the RabbitFish output; which is
      similar to the basic version, but does distinguish between elements and
      attributes. If you're dealing with a lot of data centric XML, you could
      use the highly structured Rayfish output. All four output formats ignore
      <acronym>XML</acronym> namespaces unless the
      <literal>use-namespaces</literal> parameter is set to
      <literal>true()</literal>, in which case namespaces are created
      according to the BadgerFish convention.</para>

      <para>Each format has a list of rules by which <acronym>XML</acronym> is
      transformed to <acronym>JSON</acronym>. The examples for these rules are
      all but one taken from the <ulink
      url="http://badgerfish.ning.com/">BadgerFish convention website</ulink>
      to make comparing them easier.</para>

      <section>
        <title>Basic output (default)</title>

        <para>The purpose of the basic output is to generate the most compact
        <acronym>JSON</acronym> possible. This is useful if you do not require
        round-trips between <acronym>XML</acronym> and <acronym>JSON</acronym>
        or if you need to send a large amount of data over a network. It
        borrows the <literal>$</literal> syntax for text elements from the
        BadgerFish convention but attempts to avoid needless text-only
        <acronym>JSON</acronym> properties. It also does not distinguish
        between elements and attributes. The rules are:</para>

        <orderedlist>
          <listitem>
            <para>Element names become object properties.</para>
          </listitem>

          <listitem>
            <para>Text content of elements goes directly in the value of an
            object.</para>

            <programlisting>&lt;alice&gt;bob&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": "bob" }</programlisting>
          </listitem>

          <listitem>
            <para>Nested elements become nested properties.</para>

            <programlisting>&lt;alice&gt;&lt;bob&gt;charlie&lt;/bob&gt;&lt;david&gt;edgar&lt;/david&gt;&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": { "bob": "charlie", "david": "edgar" } }</programlisting>
          </listitem>

          <listitem>
            <para>Multiple elements with the same name and at the same level
            become array elements.</para>

            <programlisting>&lt;alice&gt;&lt;bob&gt;charlie&lt;/bob&gt;&lt;bob&gt;david&lt;/bob&gt;&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": { "bob": [ "charlie", "david" ] } }</programlisting>
          </listitem>

          <listitem>
            <para>Mixed content (element and text nodes) at the same level
            become array elements.</para>

            <programlisting>&lt;alice&gt;bob&lt;charlie&gt;david&lt;/charlie&gt;edgar&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": [ "bob", { "charlie": "david" }, "edgar" ] }</programlisting>
          </listitem>

          <listitem>
            <para>Attributes go in properties.</para>

            <programlisting>&lt;alice charlie="david"&gt;bob&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": { "charlie": "david", "$": "bob" } }</programlisting>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>BadgerFish convention (use-badgerfish)</title>

        <para>The BadgerFish convention was invented by <ulink
        url="http://www.sklar.com/">David Sklar</ulink>; more detailed
        information can be found on his <ulink
        url="http://badgerfish.ning.com/">BadgerFish website</ulink>. I have
        taken some liberties in supporting BadgerFish, for example the
        treatment of mixed content nodes (nodes with both text and element
        nodes as children) which was not covered in the convention (except for
        a mention in the to-do list) but is supported by XSLTJSON. The other
        change is that namespaces are optional instead of mandatory (which is
        also mentioned in the to-do list.) The rules are:</para>

        <orderedlist>
          <listitem>
            <para>Element names become object properties.</para>
          </listitem>

          <listitem>
            <para>Text content of elements goes in the <literal>$</literal>
            property of an object.</para>

            <programlisting>&lt;alice&gt;bob&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": { "$": "bob" } }</programlisting>
          </listitem>

          <listitem>
            <para>Nested elements become nested properties.</para>

            <programlisting>&lt;alice&gt;&lt;bob&gt;charlie&lt;/bob&gt;&lt;david&gt;edgar&lt;/david&gt;&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": {"bob": { "$": "charlie" }, "david": { "$": "edgar" } } }</programlisting>
          </listitem>

          <listitem>
            <para>Multiple elements with the same name and at the same level
            become array elements.</para>

            <programlisting>&lt;alice&gt;&lt;bob&gt;charlie&lt;/bob&gt;&lt;bob&gt;david&lt;/bob&gt;&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": { "bob": [ { "$": "charlie" }, { "$": "david" } ] } }</programlisting>
          </listitem>

          <listitem>
            <para>Mixed content (element and text nodes) at the same level
            become array elements.</para>

            <programlisting>&lt;alice&gt;bob&lt;charlie&gt;david&lt;/charlie&gt;edgar&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": [ { "$": "bob" }, { "charlie": { "$": "david" } }, { "$": "edgar" } ] }</programlisting>
          </listitem>

          <listitem>
            <para>Attributes go in properties whose name begin with
            <literal>@</literal>.</para>

            <programlisting>&lt;alice charlie="david"&gt;bob&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "alice": { "@charlie": "david", "$": "bob" } }</programlisting>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>RabbitFish (use-rabbitfish)</title>

        <para>RabbitFish is identical to the basic output format except that
        it uses Rule 6 “Attributes go in properties whose name begin with
        <literal>@</literal>” from the BadgerFish convention in order to
        distinguish between elements and attributes.</para>
      </section>

      <section>
        <title>Rayfish (use-rayfish)</title>

        <para>The <ulink
        url="http://onperl.org/blog/onperl/page/rayfish">Rayfish
        convention</ulink> was invented by <ulink
        url="http://onperl.org/">Micheal Matthew</ulink> and aims to create
        highly structured <acronym>JSON</acronym> which is easy to parse and
        extract information from due to its regularity. This makes it an
        excellent choice for data centric <acronym>XML</acronym> documents.
        The downside is that it does not support mixed content (elements and
        text nodes at the same level) and is slightly more verbose than the
        other output formats. The rules are:</para>

        <orderedlist>
          <listitem>
            <para>Elements are transformed into an object with three
            properties: <literal>#name</literal>, <literal>#text</literal> and
            <literal>#children</literal>. The name property contains the name
            of the element, the text property contains the text contents of
            the element and the children property contains an array of the
            child elements.</para>

            <programlisting>&lt;alice/&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "#name": "alice", "#text": null, "#children": [ ] }</programlisting>
          </listitem>

          <listitem>
            <para>Nested elements become members of the
            <literal>#children</literal> property of the parent
            element.</para>

            <programlisting>&lt;alice&gt;&lt;bob&gt;charlie&lt;/bob&gt;&lt;david&gt;edgar&lt;/david&gt;&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "#name": "alice", "#text": null, "#children": [ 
    { "#name": "bob", "#text": "charlie", "#children": [ ] }, 
    { "#name": "david", "#text": "edgar", "#children": [ ] }
]}</programlisting>
          </listitem>

          <listitem>
            <para>Attributes go into an object in the
            <literal>#children</literal> property and begin with
            <literal>@</literal>.</para>

            <programlisting>&lt;alice charlie="david"&gt;bob&lt;/alice&gt;</programlisting>

            <para>becomes</para>

            <programlisting>{ "#name": "alice", "#text": "bob", "#children": [ 
     { "#name": "@charlie", 
       "#text": "david", 
       "#children": [ ] 
     }
]}</programlisting>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>Namespaces (use-namespaces)</title>

        <para>When turned on, namespaces are created according to the <ulink
        url="http://badgerfish.ning.com/">BadgerFish convention</ulink>. In
        basic output, the <literal>@</literal> is left out of the property
        name.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Credits</title>

    <para>Thanks to: Chick Markley (Octal number &amp; numbers with
    terminating period fix).</para>
  </section>
</article>